
from bw.util import NULL, wrapper, CodeBlock
from types import MethodType

class BWMeta(type):
    def __init__(cls, typename, typebases, typedict):
        super(BWMeta, cls).__init__(typename, typebases, typedict)
        for base in reversed(cls.__mro__):
            fn = base.__dict__.get('__bwsetup__')
            if fn is not None:
                fn(cls, base)

    def __make_bwinit__(cls, blk):
        for callback in cls.__bwinit_inline__:
            callback(cls, blk)

    def init_inline(cls, fn):
        cls.__bwinit_inline__ += (fn,)

    @wrapper
    def meta_method(cls, fn):
        import sys; print >>sys.stderr, 'HERE', cls, fn
        setattr(cls, fn.__name__, fn)

# Necessary to deal with Python2/3 compatability
BWSimpleObject = BWMeta('BWSimpleObject', (object,), dict(
    __bwchain__ = lambda _s, *_a, **_kw: super(BWSimpleObject, _s).__init__()
))

print BWSimpleObject.meta_method
@BWSimpleObject.meta_method
def __bwsetup__(cls, base):
    # Scan for local binders first
    callbacks = []
    name_sequences = {}
    for name in cls.__dict__:
        value = cls.__dict__[name]
        if isinstance(value, MethodType):
            fn = getattr(value.im_func, '__bwbind__', None)
            sequence = getattr(value.im_func, '__bwbindorder__', 0)
        else:
            fn = getattr(value, '__bwbind__', None)
            sequence = getattr(value, '__bwbindorder__', 0)
        if fn is not None:
            if fn is True:
                fn = value
            callbacks.append((sequence, name, fn))
    callbacks.sort()
    callbacks = cls.__bwcallbacks__ = tuple(callbacks)

    # Exend with binders from base classes that need also be called.
    for base in cls.__mro__:
        for callback in getattr(base, '__bwcallbacks__', ()):
            if callback not in callbacks:
                sequence, name, fn = callback
                rebind = getattr(fn, '__bwrebind__', None)
                if rebind is not None:
                    callbacks.append((sequence, name, rebind))

    # Next, apply the callbacks.  These should now be in order of:
    #
    # 1. Proximity to this class
    # 2. Sequence if specified
    # 3. Name of the method
    #
    # While doing this, we'll keep track of the values from higher
    # priority bidings to allow binders that support __bwrebind__ to be
    # called later.
    #
    metainfo = dict()
    for sequence, name, fn in callbacks:
        replacement = fn(cls, name, metainfo.get(name, getattr(cls, name)))
        if replacement is not None:
            if replacement is NULL:
                replacement = None
            metainfo[name] = replacement

    # Finally, update the class with any replacements specified.
    for name, value in metainfo.items():
        setattr(cls, name, value)
BWSimpleObject.__bwsetup__

class BWObject(BWSimpleObject):
    '''Base for all Bullwinkle-enhanced Python classes.

    =======
    Summary
    =======

    BWObject provides the base or mixin class to enable Bullwinkle features
    on the Python class inheriting from it.  These features include:

    * Ability to modify the class following creation
    * Binding of any or all members to the class via callback
    * Individual metatype creation per class
    * Combinability of classes via the addition operator
    * Creation of type constraints via bitwise-logical operators

    ====================
    Class Initialization
    ====================

    Once a class based on BWObject is created, the __bwsetup__ classmethod
    is invoked upon it.  This method can do many things, though
    registration is a typical use:

    >>> class Registered(BWObject):
    ...     registry = {}
    ...
    ...     def __bwsetup__(cls, base):
    ...         cls.registry[cls.__name__] = cls

    >>> class TypeA(Registered): pass
    >>> class TypeB(Registered): pass
    >>> sorted(Registered.registry)
    ['Registered', 'TypeA', 'TypeB']

    A few things should be noted:

    * The class being initialized will NOT be available by name when
        __bwsetup__ is called.  It is, however, the class passed.

    * All __bwsetup__ methods will be called in base-class-first order.
        This means that a subclass CANNOT prevent a base-class __bwsetup__
        from being executed.

    * As a result, __bwstup__ MUST be a staticmethod that receives cls as
        the first argument instead of a classmethod.

    ==============
    Member Binding
    ==============

    Upon creation, all BWObject-enhanced classes will scan their members
    (as well as base-class members) for binding methods.  These methods are
    called upon class initialization to potentially enhance the class or
    setup the member in some way.

    To utilize this, the member defines a __bwbind__ attribute on the
    member that is either:

    * A function (or callable) that will be invoked with the class, member
        name, and previous value as positional arguments.

    * Python True meaning the member itself should be called in such a way.

    A typical use for this is for auto-linking a member with the name
    appied by the containing class:

    >>> class DatabaseField(object):        # Note BWObject NOT reqiured
    ...     def __bwbind__(self, cls, name, value):
    ...         cls.columns += (value,)
    ...         self.name = name

    >>> class Table(BWObject):
    ...     columns = ()
    ...     id = DatabaseField()
    ...     data = DatabaseField()

    >>> sorted(column.name for column in Table.columns)
    ['data', 'id']

    If it is important for members to be initialized in a particular order,
    adding an incrementing __bwbindorder__ member tells BWObject what order
    to invoke the bindable methods in:

    >>> class DatabaseField(object):        # Note BWObject NOT reqiured
    ...     sequence = 0
    ...     def __init__(self):
    ...         self.__bwbindorder__ = self.sequence
    ...         type(self).sequence += 1
    ...
    ...     def __bwbind__(self, cls, name, value):
    ...         cls.columns += (value,)
    ...         self.name = name

    >>> class Table(BWObject):
    ...     columns = ()
    ...     id = DatabaseField()
    ...     data = DatabaseField()

    >>> tuple(column.name for column in Table.columns)
    ('id', 'data')

    Bind functions can return one of three things:

    * None -- nothing happens to the member; it is left intact.

    * NULL (type(None)) -- the member is replaced by None

    * Anything else -- the member is replaced by the result

    Being able to replace the member allows for, among other things,
    defining custom getter/setters easily:

    >>> class DatabaseField(object):        # Note BWObject NOT reqiured
    ...     sequence = 0
    ...     def __init__(self, cls):
    ...         self.__bwbindorder__ = self.sequence
    ...         self.check = cls
    ...         type(self).sequence += 1
    ...
    ...     def __bwbind__(self, cls, name, value):
    ...         cls.columns += (value,)
    ...         self.name = name
    ...         attr = '_' + name
    ...         cls = self.check
    ...         return property(lambda s: getattr(s, attr),
    ...                         lambda s, v: setattr(s, attr, cls(v)))

    >>> class Table(BWObject):          # Generalized
    ...     columns = ()
    ...
    ...     def __init__(self, **_kw):
    ...         for name, value in _kw.iteritems():
    ...             setattr(self, name, value)

    >>> class MyTable(Table):
    ...     id = DatabaseField(int)
    ...     data = DatabaseField(str)

    >>> t = MyTable(id='5', data='hello')
    >>> t.id
    5
    >>> t.data
    'hello'
    >>> t = MyTable(id='blah', data='ohno!')
    Traceback (most recent call last):
        ...
    ValueError: invalid literal for int() with base 10: 'blah'

    ======================
    Constructor Management
    ======================

    Initialization for BWObject instances is slightly different than for
    regular Python instances:

    1. __init__ is called as normal.
    2. BWObject's __init__ calls __bwinit__
    3. __bwinit__ is a method defined on *every* BWObject subclass that
        sets up automated things for the object.
    4. __bwchain__ is called to determine what arguments to send on to base
        classes of the BWObject subclass.

    Any binding member can add code to __bwinit__ by adding an
    init_inline function via @BWObject.init_inline:

    >>> class Field(object):
    ...     sequence = 0
    ...
    ...     def __init__(self, accept):
    ...         self.accept = accept
    ...         type(self).sequence += 1
    ...         self.__bwbindorder__ = self.sequence
    ...
    ...     def __bwbind__(self, cls, name, value):
    ...         self.name = name
    ...         #import pdb; pdb.set_trace()
    ...         @cls.init_inline
    ...         def setup_member(cls, blk):
    ...             blk.args.append(name)
    ...             var = blk.anon(self.accept)
    ...             if_blk = blk.add('if not isinstance(%s, %s):', name, var)
    ...             if_blk.add('raise TypeError("%s must be a %s")'
    ...                 % (name, type.__name__))
    ...             blk.add('_self.%s = %s' % (name, name))

    >>> class Table(BWObject):
    ...     id = Field(int)
    ...     data = Field(str)

    >>> t = Table(id=5, data='hello')
    >>> t.id
    5
    >>> t.data
    'hello'

    By constructing a Python function on-the-fly, BWObject initialization
    should perform around 3X (or less) slower than a normal Python
    initialization path.  This is a trade-off between convenience and
    speed.  In most cases, this is not too painful, but subclasses are
    always free to define their own __init__ path that avoids BWOject's by
    subclassing BWSimpleObject instead, allowing for member binding but
    without the automatic creation of initialization magic.

    '''

    __bwinit_inline__ = ()

    def __init__(_self, *_args, **_kw):
        _self.__bwinit__(*_args, **_kw)

    def __bwsetup__(cls, base):
        # Run following BWSimpleObject's __bwsetup__

        # And as an added bonus, set up __bwinit__.  This will be converted
        # into a real method on the first use.
        # XXX: Thread safety is an issue here.
        def __bwinit__(_self, *_args, **_kw):
            # Create the method via CodeBlock
            bwinit_blk = CodeBlock()
            bwinit_blk.args = []
            bwinit_blk.kwargs = {}
            cls.__make_bwinit__(bwinit_blk)

            # Make sure we call any base class __init__ as well.
            bwinit_blk.append('_self.__bwchain__(**_kw)')

            # Wrap the block in a function declaration using the args
            # and kw to set things up.
            args = ['_self']
            for arg in bwinit_blk.args:
                args.append(arg)
            for name in bwinit_blk.kwargs:
                value = bwinit_blk.kwargs[name]
                args.append('%s=%s'
                            % (name, bwinit_blk.anon(name, value)))
            args.append('**_kw')
            argstr = ', '.join(args)
            fnblk = CodeBlock('def __bwinit__(%s):' % argstr,
                              bwinit_blk, **bwinit_blk.vars)

            # Now use it.  This wrapper won't be called again for this
            # class.
            bwinit = cls.__bwinit__ = fnblk.extract('__bwinit__')
            bwinit.__source__ = str(fnblk)
            return _self.__bwinit__(*_args, **_kw)
        cls.__bwinit__ = __bwinit__

